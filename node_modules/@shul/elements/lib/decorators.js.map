{"version":3,"file":"decorators.js","sourceRoot":"","sources":["decorators.ts"],"names":[],"mappings":"AAOA,MAAM,UAAU,QAAQ,CAGtB,GAAG,IAAW;IACd,OAAO,UACL,QAA+B,EAC/B,OAA8D;QAE9D,OAAO,CAAC,cAAc,CAAC;YACrB,sDAAsD;YACtD,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;YAAC,IAAI,CAAC,UAAU,GAAG,KAAK,WAAU,OAA6B;gBACzF,MAAM,UAAU,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;gBACtC,MAAM,cAAc,GAClB,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;qBACnB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;gBACtC,IAAI,cAAc,CAAC,MAAM;oBACvB,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC;YAC5D,CAAC,CAAA;QACH,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;IACtB,CAAC,CAAA;AACH,CAAC","sourcesContent":["import type { LitElement, PropertyValues } from 'lit';\n\ntype PropertyKeys<T> = Parameters<PropertyValues<T>['get']>[0]\n\ntype WrapperMethod<T, Key extends keyof T> =\n  (this: T, ...args: [Record<Key, T[Key]>]) => void;\n\nexport function observes<\n  T extends LitElement,\n  Key extends PropertyKeys<T>,\n>(...keys: Key[]) {\n  return function(\n    original: WrapperMethod<T, Key>,\n    context: ClassMethodDecoratorContext<T, WrapperMethod<T, Key>>\n  ) {\n    context.addInitializer(function() {\n      // @ts-expect-error: i know its wrong but i don't mind\n      const { willUpdate } = this; this.willUpdate = async function(changed: PropertyValues<this>) {\n        await willUpdate?.call(this, changed);\n        const changedEntries =\n          [...changed.entries()]\n            .filter(([k]) => keys.includes(k))\n        if (changedEntries.length)\n          original.call(this, Object.fromEntries(changedEntries));\n      }\n    });\n    return () => void 0;\n  }\n}\n"]}