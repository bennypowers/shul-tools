/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { shuffle } from '../util/shuffle.js';
import { Deferred } from '../util/deferred.js';
let executionConstructorHook;
/**
 * For GC testing only. A function that is called whenever an Execution is
 * constructed.
 */
export function registerExecutionConstructorHook(fn) {
    executionConstructorHook = fn;
}
/**
 * A single execution of a specific script.
 */
export class BaseExecution {
    #fingerprint;
    constructor(config, executor, logger) {
        executionConstructorHook?.(this);
        this._config = config;
        this._executor = executor;
        this._logger = logger;
    }
    /**
     * Execute this script and return its fingerprint. Cached, so safe to call
     * multiple times.
     */
    execute() {
        return (this.#fingerprint ??= this._execute());
    }
    /**
     * Execute all of this script's dependencies.
     */
    async _executeDependencies() {
        // Randomize the order we execute dependencies to make it less likely for a
        // user to inadvertently depend on any specific order, which could indicate
        // a missing edge in the dependency graph.
        shuffle(this._config.dependencies);
        const dependencyResults = await Promise.all(this._config.dependencies.map((dependency) => {
            return this._executor.getExecution(dependency.config).execute();
        }));
        const results = [];
        const errors = new Set();
        for (let i = 0; i < dependencyResults.length; i++) {
            const result = dependencyResults[i];
            if (!result.ok) {
                for (const error of result.error) {
                    errors.add(error);
                }
            }
            else {
                results.push([this._config.dependencies[i], result.value]);
            }
        }
        if (errors.size > 0) {
            return { ok: false, error: [...errors] };
        }
        return { ok: true, value: results };
    }
}
/**
 * A single execution of a specific script which has a command.
 */
export class BaseExecutionWithCommand extends BaseExecution {
    constructor() {
        super(...arguments);
        this._servicesNotNeeded = new Deferred();
        /**
         * Resolves when this script no longer needs any of its service dependencies
         * to be running. This could happen because it finished, failed, or never
         * needed to run at all.
         */
        this.servicesNotNeeded = this._servicesNotNeeded.promise;
        /**
         * Resolves when any of the services this script depends on have terminated
         * (see {@link ServiceScriptExecution.terminated} for exact definiton).
         */
        this._anyServiceTerminated = Promise.race(this._config.services.map((service) => this._executor.getExecution(service).terminated));
    }
    /**
     * Ensure that all of the services this script depends on are running.
     */
    async _startServices() {
        if (this._config.services.length > 0) {
            const results = await Promise.all(this._config.services.map((service) => this._executor.getExecution(service).start()));
            const errors = [];
            for (const result of results) {
                if (!result.ok) {
                    errors.push(result.error);
                }
            }
            if (errors.length > 0) {
                return { ok: false, error: errors };
            }
        }
        return { ok: true, value: undefined };
    }
}
//# sourceMappingURL=base.js.map