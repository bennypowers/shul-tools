/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import * as fs from '../util/fs.js';
import * as pathlib from 'path';
import { createHash } from 'crypto';
import { getScriptDataDir } from '../util/script-data-dir.js';
import { copyEntries } from '../util/copy.js';
import { glob } from '../util/glob.js';
/**
 * Caches script output to each package's
 * ".wireit/<script-name-hex>/cache/<cache-key-sha256-hex>" folder.
 */
export class LocalCache {
    async get(script, fingerprint) {
        const cacheDir = this.#getCacheDir(script, fingerprint);
        try {
            await fs.access(cacheDir);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                return;
            }
            throw error;
        }
        return new LocalCacheHit(cacheDir, script.packageDir);
    }
    async set(script, fingerprint, absoluteFiles) {
        // TODO(aomarks) A script's cache directory currently just grows forever.
        // We'll have the "clean" command to help with manual cleanup, but we'll
        // almost certainly want an automated way to limit the size of the cache
        // directory (e.g. LRU capped to some number of entries).
        // https://github.com/google/wireit/issues/71
        const absCacheDir = this.#getCacheDir(script, fingerprint);
        // Note fs.mkdir returns the first created directory, or undefined if no
        // directory was created.
        const existed = (await fs.mkdir(absCacheDir, { recursive: true })) === undefined;
        if (existed) {
            // This is an unexpected error because the Executor should already have
            // checked for an existing cache hit.
            throw new Error(`Did not expect ${absCacheDir} to already exist.`);
        }
        await copyEntries(absoluteFiles, script.packageDir, absCacheDir);
        return true;
    }
    #getCacheDir(script, fingerprint) {
        return pathlib.join(getScriptDataDir(script), 'cache', createHash('sha256').update(fingerprint.string).digest('hex'));
    }
}
class LocalCacheHit {
    /**
     * The folder where the cached output is stored. Assumed to exist.
     */
    #source;
    /**
     * The folder where the cached output should be written when {@link apply} is
     * called.
     */
    #destination;
    constructor(source, destination) {
        this.#source = source;
        this.#destination = destination;
    }
    async apply() {
        const entries = await glob(['**'], {
            cwd: this.#source,
            followSymlinks: false,
            includeDirectories: true,
            expandDirectories: true,
            // Shouldn't ever happen, but would be really weird.
            throwIfOutsideCwd: true,
        });
        await copyEntries(entries, this.#source, this.#destination);
    }
}
//# sourceMappingURL=local-cache.js.map