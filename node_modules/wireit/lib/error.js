/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import * as pathlib from 'path';
export class DiagnosticPrinter {
    #cwd;
    /**
     * @param workingDir Paths are printed relative to this directory.
     */
    constructor(workingDir) {
        this.#cwd = workingDir;
    }
    print(diagnostic) {
        if (diagnostic.location.range.length < 0) {
            throw new Error(`Internal error: got a negative length squiggle for ${diagnostic.message}: ${diagnostic.location.range.length}`);
        }
        const path = this.#formatPath(diagnostic.location);
        let result = `❌ ${path} ${diagnostic.message}
${drawSquiggle(diagnostic.location, 4)}`;
        if (diagnostic.supplementalLocations) {
            for (const supplementalLocation of diagnostic.supplementalLocations) {
                result += '\n\n' + this.#printSupplemental(supplementalLocation);
            }
        }
        return result;
    }
    #printSupplemental(supplemental) {
        const squiggle = drawSquiggle(supplemental.location, 8);
        const path = this.#formatPath(supplemental.location);
        return `    ${path} ${supplemental.message}\n${squiggle}`;
    }
    #formatPath(location) {
        const relPath = pathlib.relative(this.#cwd, location.file.path);
        const { line, character } = this.#offsetToPosition(location.file, location.range.offset);
        return `${CYAN}${relPath}${RESET}:${YELLOW}${line}${RESET}:${YELLOW}${character}${RESET}`;
    }
    #offsetToPosition(file, offset) {
        return OffsetToPositionConverter.get(file).toPosition(offset);
    }
}
export class OffsetToPositionConverter {
    static #cache = new WeakMap();
    static get(file) {
        let converter = OffsetToPositionConverter.#cache.get(file);
        if (converter === undefined) {
            converter = new OffsetToPositionConverter(file.contents);
            OffsetToPositionConverter.#cache.set(file, converter);
        }
        return converter;
    }
    static createUncachedForTest(contents) {
        return new OffsetToPositionConverter(contents);
    }
    constructor(contents) {
        const indexes = [];
        for (let i = 0; i < contents.length; i++) {
            if (contents[i] === '\n') {
                indexes.push(i);
            }
        }
        this.newlineIndexes = indexes;
    }
    toPosition(offset) {
        if (this.newlineIndexes.length === 0) {
            return { line: 1, character: offset + 1 };
        }
        const line = this.newlineIndexes.findIndex((index) => index >= offset);
        if (line === 0) {
            return { line: 1, character: offset + 1 };
        }
        if (line === -1) {
            return {
                line: this.newlineIndexes.length + 1,
                character: offset - (this.newlineIndexes[this.newlineIndexes.length - 1] ?? 0),
            };
        }
        return {
            line: line + 1,
            character: offset - (this.newlineIndexes[line - 1] ?? 0),
        };
    }
    toIdePosition(offset) {
        const position = this.toPosition(offset);
        return { line: position.line - 1, character: position.character - 1 };
    }
    toIdeRange(range) {
        const start = this.toIdePosition(range.offset);
        const end = this.toIdePosition(range.offset + range.length);
        return { start, end };
    }
    idePositionToOffset(position) {
        let lineOffset = this.newlineIndexes[position.line - 1];
        lineOffset = lineOffset === undefined ? 0 : lineOffset + 1;
        return lineOffset + position.character;
    }
    ideRangeToRange(range) {
        const start = this.idePositionToOffset(range.start);
        const end = this.idePositionToOffset(range.end);
        return { offset: start, length: end - start };
    }
}
const CYAN = '\x1b[36m';
const YELLOW = '\x1b[33m';
const RED = '\x1b[31m';
const RESET = '\x1b[0m';
// Exported for testing
export function drawSquiggle(location, indent) {
    let { range: { offset, length }, } = location;
    const fileContents = location.file.contents;
    const startOfInitialLine = fileContents.slice(0, offset).lastIndexOf('\n') + 1;
    const uncorrectedFirstNewlineIndexAfter = fileContents
        .slice(offset + length)
        .indexOf('\n');
    const endOfLastLine = uncorrectedFirstNewlineIndexAfter === -1
        ? undefined
        : offset + length + uncorrectedFirstNewlineIndexAfter;
    offset = offset - startOfInitialLine;
    const sectionToPrint = fileContents.slice(startOfInitialLine, endOfLastLine);
    let result = '';
    for (const line of sectionToPrint.split('\n')) {
        result += `${' '.repeat(indent)}${line}\n`;
        const squiggleLength = Math.min(line.length - offset, length);
        result +=
            ' '.repeat(offset + indent) +
                `${RED}${'~'.repeat(squiggleLength)}${RESET}\n`;
        offset = 0;
        length -= squiggleLength + 1; // +1 to account for the newline
    }
    // Drop the last newline.
    return result.slice(0, -1);
}
export const offsetInsideRange = (offset, range) => offset >= range.offset && offset < range.offset + range.length;
export const offsetInsideNamedNode = (offset, namedNode) => {
    const valueEnd = namedNode.offset + namedNode.length;
    const totalLength = valueEnd - namedNode.name.offset;
    return offsetInsideRange(offset, {
        offset: namedNode.name.offset,
        length: totalLength,
    });
};
/**
 * Convert an unexpected exception to a {@link UnknownErrorThrown} failure,
 * which includes the sript context for better debugging.
 */
export function convertExceptionToFailure(error, script) {
    return {
        ok: false,
        error: [
            {
                type: 'failure',
                reason: 'unknown-error-thrown',
                script,
                error,
            },
        ],
    };
}
//# sourceMappingURL=error.js.map