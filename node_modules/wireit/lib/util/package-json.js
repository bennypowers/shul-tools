/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { findNamedNodeAtLocation } from './ast.js';
import { failUnlessJsonObject, failUnlessKeyValue, failUnlessNonBlankString, } from '../analyzer.js';
import { offsetInsideNamedNode, offsetInsideRange } from '../error.js';
/**
 * A parsed and minimally analyzed package.json file.
 *
 * This does some very basic syntactic analysis of the package.json file,
 * finding issues like "the scripts section isn't an object mapping strings to
 * strings" and "the wireit section isn't an object mapping strings to objects".
 *
 * Makes it easy to find the syntax nodes for a script.
 *
 * Does not do any validation or analysis of the wireit script configs.
 *
 * This class exists in part so that we walk the package.json file only once,
 * and in part so that we generate file-level syntactic diagnostics only once,
 * so that we can do better deduplication of errors.
 */
export class PackageJson {
    // We keep the file level AST node private to represent the invariant that
    // we only walk the file once, in this class, and nowhere else.
    #fileAstNode;
    #scripts;
    constructor(jsonFile, fileAstNode) {
        this.#scripts = new Map();
        this.scriptsSection = undefined;
        this.wireitSection = undefined;
        this.jsonFile = jsonFile;
        this.#fileAstNode = fileAstNode;
        const failures = [];
        this.scriptsSection = this.#analyzeScriptsSection(failures);
        this.wireitSection = this.#analyzeWireitSection(failures);
        this.failures = failures;
    }
    getScriptInfo(name) {
        return this.#scripts.get(name);
    }
    get scripts() {
        return this.#scripts.values();
    }
    getInfoAboutLocation(offset) {
        if (this.scriptsSection && offsetInsideRange(offset, this.scriptsSection)) {
            for (const scriptSyntaxInfo of this.scripts) {
                if (scriptSyntaxInfo.scriptNode &&
                    offsetInsideNamedNode(offset, scriptSyntaxInfo.scriptNode)) {
                    return { kind: 'scripts-section-script', scriptSyntaxInfo };
                }
            }
        }
        else if (this.wireitSection &&
            offsetInsideRange(offset, this.wireitSection)) {
            for (const scriptSyntaxInfo of this.scripts) {
                if (scriptSyntaxInfo.wireitConfigNode &&
                    offsetInsideNamedNode(offset, scriptSyntaxInfo.wireitConfigNode)) {
                    return { kind: 'wireit-section-script', scriptSyntaxInfo };
                }
            }
        }
    }
    #getOrMakeScriptInfo(name) {
        let info = this.#scripts.get(name);
        if (info === undefined) {
            info = { name };
            this.#scripts.set(name, info);
        }
        return info;
    }
    /**
     * Do some basic structural validation of the "scripts" section of this
     * package.json file. Create placeholders for each of the declared scripts and
     * add them to this._scripts.
     */
    #analyzeScriptsSection(failures) {
        const scriptsSectionResult = findNamedNodeAtLocation(this.#fileAstNode, ['scripts'], this.jsonFile);
        if (!scriptsSectionResult.ok) {
            failures.push(scriptsSectionResult.error);
            return;
        }
        const scriptsSection = scriptsSectionResult.value;
        if (scriptsSection === undefined) {
            return;
        }
        const fail = failUnlessJsonObject(scriptsSection, this.jsonFile);
        if (fail !== undefined) {
            failures.push(fail);
            return;
        }
        for (const child of scriptsSection.children ?? []) {
            if (child.type !== 'property') {
                continue;
            }
            if (child.children === undefined) {
                continue;
            }
            const nameAndValueResult = failUnlessKeyValue(child, child.children, this.jsonFile);
            if (!nameAndValueResult.ok) {
                failures.push(nameAndValueResult.error);
                continue;
            }
            const [rawName, rawValue] = nameAndValueResult.value;
            const nameResult = failUnlessNonBlankString(rawName, this.jsonFile);
            if (!nameResult.ok) {
                failures.push(nameResult.error);
                continue;
            }
            const valueResult = failUnlessNonBlankString(rawValue, this.jsonFile);
            if (!valueResult.ok) {
                failures.push(valueResult.error);
                continue;
            }
            const scriptAstNode = valueResult.value;
            scriptAstNode.name = nameResult.value;
            this.#getOrMakeScriptInfo(nameResult.value.value).scriptNode =
                scriptAstNode;
        }
        return scriptsSectionResult.value;
    }
    /**
     * Do some basic structural validation of the "wireit" section of this
     * package.json file.
     *
     * Create placeholders for each of the declared scripts and
     * add them to this._scripts.
     *
     * Does not do any validation of any wireit configs themselves, that's done
     * on demand when executing, or all at once when finding all diagnostics.
     */
    #analyzeWireitSection(failures) {
        const wireitSectionResult = findNamedNodeAtLocation(this.#fileAstNode, ['wireit'], this.jsonFile);
        if (!wireitSectionResult.ok) {
            failures.push(wireitSectionResult.error);
            return;
        }
        const wireitSection = wireitSectionResult.value;
        if (wireitSection === undefined) {
            return;
        }
        const fail = failUnlessJsonObject(wireitSection, this.jsonFile);
        if (fail !== undefined) {
            failures.push(fail);
            return;
        }
        for (const child of wireitSection.children ?? []) {
            if (child.type !== 'property') {
                continue;
            }
            if (child.children === undefined) {
                continue;
            }
            const nameAndValueResult = failUnlessKeyValue(child, child.children, this.jsonFile);
            if (!nameAndValueResult.ok) {
                failures.push(nameAndValueResult.error);
                continue;
            }
            const [rawName, rawValue] = nameAndValueResult.value;
            const nameResult = failUnlessNonBlankString(rawName, this.jsonFile);
            if (!nameResult.ok) {
                failures.push(nameResult.error);
                continue;
            }
            const fail = failUnlessJsonObject(rawValue, this.jsonFile);
            if (fail !== undefined) {
                failures.push(fail);
                continue;
            }
            const wireitConfigNode = rawValue;
            wireitConfigNode.name = nameResult.value;
            this.#getOrMakeScriptInfo(nameResult.value.value).wireitConfigNode =
                wireitConfigNode;
        }
        return wireitSectionResult.value;
    }
}
//# sourceMappingURL=package-json.js.map