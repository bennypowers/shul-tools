/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
import * as fs from 'fs/promises';
import { createReadStream as rawCreateReadStream, createWriteStream as rawCreateWriteStream, } from 'fs';
import { Deferred } from './deferred.js';
import './dispose.js';
export { constants } from 'fs';
export class Semaphore {
    #remaining;
    #waiting = [];
    constructor(numSlots) {
        if (numSlots <= 0) {
            throw new Error(`numSlots must be positive, got ${numSlots}`);
        }
        this.#remaining = numSlots;
    }
    async reserve() {
        while (this.#remaining === 0) {
            const deferred = new Deferred();
            this.#waiting.push(deferred);
            await deferred.promise;
        }
        this.#remaining--;
        let disposed = false;
        return {
            [Symbol.dispose]: () => {
                if (disposed) {
                    return;
                }
                disposed = true;
                this.#remaining++;
                if (this.#waiting.length > 0) {
                    this.#waiting.pop()?.resolve();
                }
            },
        };
    }
}
export const fileBudget = (() => {
    let maxOpenFiles = Number(process.env['WIREIT_MAX_OPEN_FILES']);
    if (isNaN(maxOpenFiles)) {
        // This is tricky to get right. There's no simple cross-platform way to
        // determine what our current limits are. Windows it's 512, on macOS it
        // defaults to 256, and on Linux it varies a lot.
        // 200 gives us a bit of headroom for other things that might be using
        // file descriptors in our process, like node internals.
        maxOpenFiles = 200;
    }
    return new Semaphore(maxOpenFiles);
})();
export async function mkdir(path, options) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.mkdir(path, options);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function mkdtemp(path) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.mkdtemp(path);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function writeFile(path, contents, encoding) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.writeFile(path, contents, encoding);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function readFile(path, encoding) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.readFile(path, encoding);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function rm(path, options) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.rm(path, options);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function lstat(path) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.lstat(path);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function stat(path) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.stat(path);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function access(path) {
    const reservation = await fileBudget.reserve();
    try {
        return fs.access(path);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function createReadStream(path, options) {
    const reservation = await fileBudget.reserve();
    const stream = rawCreateReadStream(path, options);
    stream.on('close', () => reservation[Symbol.dispose]());
    return stream;
}
export async function createWriteStream(path) {
    const reservation = await fileBudget.reserve();
    const stream = rawCreateWriteStream(path);
    stream.on('close', () => reservation[Symbol.dispose]());
    return stream;
}
export async function copyFile(src, dest, flags) {
    const reservation = await fileBudget.reserve();
    try {
        return await fs.copyFile(src, dest, flags);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function readlink(path, options) {
    const reservation = await fileBudget.reserve();
    try {
        return await fs.readlink(path, options);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function symlink(target, path, type) {
    const reservation = await fileBudget.reserve();
    try {
        return await fs.symlink(target, path, type);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function unlink(target) {
    const reservation = await fileBudget.reserve();
    try {
        return await fs.unlink(target);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function rmdir(target) {
    const reservation = await fileBudget.reserve();
    try {
        return await fs.rmdir(target);
    }
    finally {
        reservation[Symbol.dispose]();
    }
}
export async function readdir(path, options) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        const _reservation = __addDisposableResource(env_1, await fileBudget.reserve(), false);
        return await fs.readdir(path, options);
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        __disposeResources(env_1);
    }
}
//# sourceMappingURL=fs.js.map