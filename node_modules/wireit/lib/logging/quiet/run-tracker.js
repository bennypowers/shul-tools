/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
import { inspect } from 'util';
import { scriptReferenceToString, } from '../../config.js';
import { DefaultLogger, labelForScript } from '../default-logger.js';
import { DEBUG } from '../logger.js';
import { StackMap } from './stack-map.js';
// To prevent using the global console accidentally, we shadow it with
// undefined
const console = undefined;
function markAsUsed(_) { }
markAsUsed(console);
/**
 * State that the run tracker cares about for a currently running script.
 */
class ScriptState {
    #outputBuffer = [];
    constructor(scriptReference, service, isRootScript) {
        this.scriptReference = scriptReference;
        this.service = service;
        this.isRootScript = isRootScript;
    }
    bufferOutput(output) {
        if (output.data.length === 0) {
            return;
        }
        this.#outputBuffer.push({
            stream: output.stream,
            data: output.data,
        });
    }
    replayAndEmptyBuffer() {
        for (const output of this.#outputBuffer) {
            if (output.stream === 'stdout') {
                process.stdout.write(output.data);
            }
            else {
                process.stderr.write(output.data);
            }
        }
        this.#outputBuffer.length = 0;
    }
    get hasBufferedOutput() {
        return this.#outputBuffer.length > 0;
    }
}
export const noChange = Symbol('nochange');
export const nothing = Symbol('nothing');
/**
 * Tracks the state of a run, and produces a single line of status text.
 *
 * A QuietLogger usually just has one of these, but in --watch mode we use
 * one per iteration.
 */
export class QuietRunLogger {
    /**
     * Currently running scripts, or failed scripts that we're about to
     * report on. A script is added to this when it starts, and removed
     * only when it successfully exits.
     *
     * Keyed by this._getKey
     */
    #running = new StackMap();
    /** The number of commands we've started. */
    #ran = 0;
    /**
     * The number of scripts with commands that were either fresh or whose output
     * we restored.
     */
    #skipped = 0;
    #encounteredFailures = false;
    #servicesRunning = 0;
    #servicesStarted = 0;
    #servicesPersistedFromPreviousRun = 0;
    #analysisInfo = undefined;
    #finishedScriptsWithCommands = new Set();
    #statusLineState = 'initial';
    #startTime = Date.now();
    #rootPackage;
    #defaultLogger;
    #statusLineWriter;
    /**
     * Sometimes a script will fail multiple times, but we only want to report
     * about the first failure for it that we find. Sometimes a script will
     * even end up with multiple failures for the same reason, like multiple
     * non-zero-exit-code events. This looks to be coming at the NodeJS level
     * or above, and so we just cope.
     */
    #scriptsWithAlreadyReportedError = new Set();
    constructor(rootPackage, statusLineWriter, console, defaultLogger) {
        this.#rootPackage = rootPackage;
        this.#statusLineWriter = statusLineWriter;
        this.#defaultLogger =
            defaultLogger ?? new DefaultLogger(rootPackage, console);
        this.console = console;
    }
    /**
     * Used to make a new instance, keeping info about persistent services
     * that continue from the previous run to the next.
     */
    makeInstanceForNextWatchRun() {
        // Reuse the default logger, a minor savings.
        const instance = new QuietRunLogger(this.#rootPackage, this.#statusLineWriter, this.console, this.#defaultLogger);
        // Persistent services stay running between runs, so pass along what we
        // know.
        for (const [key, state] of this.#running) {
            if (state.service) {
                instance.#servicesPersistedFromPreviousRun++;
                instance.#servicesRunning++;
                instance.#running.set(key, state);
                instance.#markScriptAsFinished(state.scriptReference);
            }
        }
        return instance;
    }
    /**
     * Takes an Event and updates our summary stats for this run.
     *
     * If it returns undefined, the previous message is still good. If it returns
     * null, the message should be cleared entirely.
     */
    getUpdatedMessageAfterEvent(event) {
        switch (event.type) {
            case 'success': {
                return this.#handleSuccess(event);
            }
            case 'failure': {
                return this.#handleFailure(event);
            }
            case 'info': {
                return this.#handleInfo(event);
            }
            case 'output': {
                return this.#handleOutput(event);
            }
            default: {
                const never = event;
                throw new Error(`Unknown event type: ${JSON.stringify(never)}`);
            }
        }
    }
    /**
     * Should be called once, at the end of a run.
     */
    printSummary() {
        this.#statusLineState = 'done';
        let scriptsStillRunning = false;
        for (const state of this.#running.values()) {
            if (state.service) {
                continue;
            }
            scriptsStillRunning = true;
        }
        if (this.#encounteredFailures || scriptsStillRunning) {
            this.#printFailureSummary();
            return;
        }
        this.#printSuccessSummary();
    }
    #printFailureSummary() {
        for (const [, state] of this.#running) {
            const label = labelForScript(this.#rootPackage, state.scriptReference);
            const key = scriptReferenceToString(state.scriptReference);
            if (this.#scriptsWithAlreadyReportedError.has(key) || state.service) {
                continue;
            }
            // We expected this to finish running, but it didn't. We haven't seen
            // this in our testing, so it's as much of a test of our own code as
            // anything else.
            process.stderr.write(`\n❌ [${label}] did not exit successfully.`);
            this.#reportOutputForFailingScript(state.scriptReference);
        }
        if (this.#scriptsWithAlreadyReportedError.size > 0) {
            const s = this.#scriptsWithAlreadyReportedError.size === 1 ? '' : 's';
            process.stderr.write(`❌ ${this.#scriptsWithAlreadyReportedError.size.toLocaleString()} script${s} failed.\n`);
        }
        else {
            process.stderr.write(`❌ Failed.\n`);
        }
    }
    #printSuccessSummary() {
        const elapsed = Math.round((Date.now() - this.#startTime) / 100) / 10;
        // In watch mode, we want to count services that we started as part of this
        // run.
        const count = this.#ran + this.#servicesStarted;
        const s = count === 1 ? '' : 's';
        this.console.log(`✅ Ran ${count.toLocaleString()} script${s} and skipped ${this.#skipped.toLocaleString()} in ${elapsed.toLocaleString()}s.`);
    }
    #reportOutputForFailingScript(script, cause) {
        const state = this.#running.get(scriptReferenceToString(script));
        if (!state) {
            throw new Error(`Internal error: Got ${cause?.reason ? `${cause.reason} event` : 'leftover script'} for script without a start event. Events delivered out of order?
    Script with failure: ${scriptReferenceToString(script)}
    Known scripts: ${inspect([...this.#running.keys()])}
`);
        }
        state.replayAndEmptyBuffer();
    }
    #getStatusLine() {
        switch (this.#statusLineState) {
            case 'initial': {
                return 'Starting';
            }
            case 'analyzing': {
                return 'Analyzing';
            }
            case 'executing': {
                if (this.#analysisInfo === undefined) {
                    return `??? Internal error: Analysis info missing ???`;
                }
                return this.#getExecutionStatusLine(this.#analysisInfo);
            }
            case 'done': {
                // No status line now.
                return nothing;
            }
            default: {
                const never = this.#statusLineState;
                throw new Error(`Unknown status line state: ${JSON.stringify(never)}`);
            }
        }
    }
    #getExecutionStatusLine(analysisInfo) {
        const peekResult = this.#running.peek()?.[1];
        let mostRecentScript = '';
        if (peekResult !== undefined) {
            mostRecentScript =
                ' ' + labelForScript(this.#rootPackage, peekResult.scriptReference);
        }
        const done = this.#finishedScriptsWithCommands.size;
        const total = analysisInfo.scriptsWithCommands.size;
        const percentDone = String(Math.round((done / total) * 100)).padStart(3, ' ') + '%';
        let servicesInfo = '';
        if (analysisInfo.hasServices) {
            const s = this.#servicesRunning === 1 ? '' : 's';
            servicesInfo = ` [${this.#servicesRunning.toLocaleString()} service${s}]`;
        }
        let failureInfo = '';
        if (this.#scriptsWithAlreadyReportedError.size > 0) {
            failureInfo = ` [${this.#scriptsWithAlreadyReportedError.size.toLocaleString()} failed]`;
        }
        return `${percentDone} [${done.toLocaleString()} / ${total}] [${this.#running.size} running]${servicesInfo}${failureInfo}${mostRecentScript}`;
    }
    #markScriptAsFinished(script) {
        const key = scriptReferenceToString(script);
        // Almost always, a script that's finished will be one that we intended
        // to execute as part of this run. However there's one exception:
        // if a persistent service was started as part of the previous run, but then
        // we change the package.json files so that we no longer need to run it,
        // it will be shut down as part of _our_ run. In that case, we don't want
        // to count it towards our total.
        const isScriptOfInterest = 
        // Optimistically mark it as finished if we don't have analysis info yet.
        // We'll remove it later if we find out it's not actually a script we
        // care about.
        this.#analysisInfo === undefined ||
            this.#analysisInfo.scriptsWithCommands.has(key);
        if (isScriptOfInterest) {
            this.#finishedScriptsWithCommands.add(key);
        }
    }
    #handleInfo(event) {
        if (DEBUG) {
            this.console.log(`info: ${event.detail} ${labelForScript(this.#rootPackage, event.script)}`);
        }
        switch (event.detail) {
            case 'running': {
                const key = scriptReferenceToString(event.script);
                this.#running.set(key, new ScriptState(event.script, false, this.#analysisInfo?.rootScript === key));
                return this.#getStatusLine();
            }
            case 'service-process-started': {
                // Services don't end, so we count this as having finished.
                this.#servicesRunning++;
                this.#servicesStarted++;
                const key = scriptReferenceToString(event.script);
                this.#running.set(key, new ScriptState(event.script, true, this.#analysisInfo?.rootScript === key));
                this.#markScriptAsFinished(event.script);
                return this.#getStatusLine();
            }
            case 'service-stopped':
                this.#servicesRunning--;
                this.#running.delete(scriptReferenceToString(event.script));
                return this.#getStatusLine();
            case 'service-ready':
            case 'watch-run-start':
            case 'watch-run-end':
                return noChange;
            case 'locked': {
                // the script is blocked on starting because something else is
                // using a shared resource
                return noChange;
            }
            case 'output-modified': {
                // the script is being run because its output files have changed
                // log nothing
                return noChange;
            }
            case 'cache-info': {
                // chatty event, e.g. transitory GitHub API errors.
                // definitely don't log anything here
                return noChange;
            }
            case 'analysis-started': {
                this.#statusLineState = 'analyzing';
                return this.#getStatusLine();
            }
            case 'analysis-completed': {
                if (!event.rootScriptConfig) {
                    // will report the error in printSummary
                    this.#statusLineState = 'done';
                    return nothing;
                }
                else {
                    this.#statusLineState = 'executing';
                    this.#analysisInfo = this.#countScriptsWithCommands(event.rootScriptConfig);
                    for (const finished of this.#finishedScriptsWithCommands) {
                        if (!this.#analysisInfo.scriptsWithCommands.has(finished)) {
                            this.#finishedScriptsWithCommands.delete(finished);
                        }
                    }
                }
                return this.#getStatusLine();
            }
            default: {
                const never = event;
                throw new Error(`Unknown info event: ${JSON.stringify(never)}`);
            }
        }
    }
    #handleSuccess(event) {
        if (DEBUG) {
            this.console.log(`success: ${event.reason} ${labelForScript(this.#rootPackage, event.script)}`);
        }
        switch (event.reason) {
            case 'cached': {
                this.#markScriptAsFinished(event.script);
                this.#skipped++;
                return this.#getStatusLine();
            }
            case 'fresh': {
                this.#markScriptAsFinished(event.script);
                this.#skipped++;
                return this.#getStatusLine();
            }
            case 'exit-zero': {
                this.#running.delete(scriptReferenceToString(event.script));
                this.#markScriptAsFinished(event.script);
                this.#ran++;
                return this.#getStatusLine();
            }
            case 'no-command': {
                return noChange;
            }
            default: {
                const never = event;
                throw new Error(`Unknown success event: ${JSON.stringify(never)}`);
            }
        }
    }
    #handleFailure(event) {
        if (DEBUG) {
            this.console.log(`failure: ${event.reason} ${labelForScript(this.#rootPackage, event.script)}`);
        }
        this.#encounteredFailures = true;
        {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _pause = __addDisposableResource(env_1, this.#statusLineWriter.clearUntilDisposed(), false);
                this.#reportFailure(event);
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources(env_1);
            }
        }
        return noChange;
    }
    #reportFailure(failure) {
        const key = scriptReferenceToString(failure.script);
        if (this.#scriptsWithAlreadyReportedError.has(key)) {
            return;
        }
        this.#scriptsWithAlreadyReportedError.add(key);
        const label = labelForScript(this.#rootPackage, failure.script);
        switch (failure.reason) {
            case 'exit-non-zero':
            case 'signal':
            case 'killed': {
                let message;
                if (failure.reason === 'exit-non-zero') {
                    message = `exited with exit code ${failure.status}`;
                }
                else if (failure.reason === 'signal') {
                    message = `was killed by signal ${failure.signal}`;
                }
                else {
                    message = `killed`;
                }
                const scriptHadOutput = this.#scriptHadOutput(failure.script);
                const trailer = scriptHadOutput ? ' Output:\n' : '';
                process.stderr.write(`\n❌ [${label}] ${message}.${trailer}\n`);
                if (scriptHadOutput) {
                    this.#reportOutputForFailingScript(failure.script, failure);
                }
                this.#finishedScriptsWithCommands.add(key);
                this.#running.delete(key);
                return this.#getStatusLine();
            }
            case 'start-cancelled':
            case 'aborted': {
                // These events aren't very useful to log, because they are downstream
                // of failures that already get reported elsewhere.
                this.#running.delete(scriptReferenceToString(failure.script));
                return this.#getStatusLine();
            }
            case 'dependency-service-exited-unexpectedly': {
                // Also logged elswhere.
                break;
            }
            case 'service-exited-unexpectedly':
            case 'cycle':
            case 'dependency-invalid':
            case 'dependency-on-missing-package-json':
            case 'dependency-on-missing-script':
            case 'duplicate-dependency':
            case 'failed-previous-watch-iteration':
            case 'invalid-config-syntax':
            case 'invalid-json-syntax':
            case 'invalid-usage':
            case 'launched-incorrectly':
            case 'missing-package-json':
            case 'no-scripts-in-package-json':
            case 'script-not-found':
            case 'script-not-wireit':
            case 'spawn-error':
            case 'unknown-error-thrown':
            case 'wireit-config-but-no-script':
                // The default log for these is good.
                this.#defaultLogger.log(failure);
                break;
            default: {
                const never = failure;
                throw new Error(`Unknown failure event: ${JSON.stringify(never)}`);
            }
        }
    }
    #scriptHadOutput(script) {
        const state = this.#running.get(scriptReferenceToString(script));
        if (!state) {
            throw new Error(`Internal error: could not find state for failing script. Events delivered out of order?
        Script with output: ${labelForScript(this.#rootPackage, script)}
        ${this.#running.size.toLocaleString()} known running scripts: ${inspect([...this.#running.keys()])}`);
        }
        return state.hasBufferedOutput;
    }
    #handleOutput(event) {
        const key = scriptReferenceToString(event.script);
        const state = this.#running.get(key);
        if (!state) {
            throw new Error(`Internal error: Got output event for unknown script. Events delivered out of order?
        Script with output: ${labelForScript(this.#rootPackage, event.script)}
        ${this.#running.size.toLocaleString()} known running scripts: ${inspect([...this.#running.keys()])}`);
        }
        if (state.service) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
                // Pause the status line while we print this real quick, but then resume
                // it.
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _pause = __addDisposableResource(env_2, this.#statusLineWriter.clearUntilDisposed(), false);
                if (event.stream === 'stdout') {
                    process.stdout.write(event.data);
                }
                else {
                    process.stderr.write(event.data);
                }
                return noChange;
            }
            catch (e_2) {
                env_2.error = e_2;
                env_2.hasError = true;
            }
            finally {
                __disposeResources(env_2);
            }
        }
        if (state.isRootScript) {
            this.#statusLineState = 'done';
            // Unlike for a service, this is a terminal state, instead of pausing the
            // status line, we stop it completely, because for the rest of the run
            // we're just going to be  printing the root script's output.
            this.#statusLineWriter.clearAndStopRendering();
            if (event.stream === 'stdout') {
                process.stdout.write(event.data);
            }
            else {
                process.stderr.write(event.data);
            }
            return nothing;
        }
        // Buffer everything else so that we can print it
        // (possibly a second time) in case of failure.
        state.bufferOutput(event);
        return noChange;
    }
    #countScriptsWithCommands(rootScript) {
        const scriptsWithCommands = new Set();
        let hasServices = false;
        const seen = new Set([scriptReferenceToString(rootScript)]);
        const toVisit = [rootScript];
        while (toVisit.length > 0) {
            const script = toVisit.pop();
            if (script.service) {
                hasServices = true;
            }
            if (script.command !== undefined) {
                // We only want to count scripts that actually run, rather than
                // just holding dependencies.
                scriptsWithCommands.add(scriptReferenceToString(script));
            }
            for (const dependency of script.dependencies.values()) {
                const key = scriptReferenceToString(dependency.config);
                if (seen.has(key)) {
                    continue;
                }
                seen.add(key);
                toVisit.push(dependency.config);
            }
        }
        return {
            rootScript: scriptReferenceToString(rootScript),
            scriptsWithCommands,
            hasServices,
        };
    }
    [Symbol.dispose]() {
        this.#defaultLogger[Symbol.dispose]();
    }
}
//# sourceMappingURL=run-tracker.js.map