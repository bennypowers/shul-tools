/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import * as pathlib from 'path';
import { unreachable } from '../util/unreachable.js';
import { DiagnosticPrinter } from '../error.js';
import { createRequire } from 'module';
import { WatchLogger } from './watch-logger.js';
const getWireitVersion = (() => {
    let version;
    return () => {
        if (version === undefined) {
            version = createRequire(import.meta.url)('../../package.json').version;
        }
        return version;
    };
})();
// To prevent using the global console accidentally, we shadow it with
// undefined
const console = undefined;
function markAsUsed(_) { }
markAsUsed(console);
/**
 * Default {@link Logger} which logs to stdout and stderr.
 */
export class DefaultLogger {
    #rootPackageDir;
    #diagnosticPrinter;
    /**
     * @param rootPackage The npm package directory that the root script being
     * executed belongs to.
     */
    constructor(rootPackage, ourConsole) {
        this.#rootPackageDir = rootPackage;
        this.#diagnosticPrinter = new DiagnosticPrinter(this.#rootPackageDir);
        this.console = ourConsole;
    }
    log(event) {
        const type = event.type;
        const label = labelForScript(this.#rootPackageDir, event.script);
        const prefix = label !== '' ? ` [${label}]` : '';
        switch (type) {
            default: {
                throw new Error(`Unknown event type: ${unreachable(type)}`);
            }
            case 'success': {
                const reason = event.reason;
                switch (reason) {
                    default: {
                        throw new Error(`Unknown success reason: ${unreachable(reason)}`);
                    }
                    case 'exit-zero': {
                        this.console.log(`‚úÖ${prefix} Executed successfully`);
                        break;
                    }
                    case 'no-command': {
                        this.console.log(`‚úÖ${prefix} No command to execute`);
                        break;
                    }
                    case 'fresh': {
                        this.console.log(`‚úÖ${prefix} Already fresh`);
                        break;
                    }
                    case 'cached': {
                        this.console.log(`‚úÖ${prefix} Restored from cache`);
                        break;
                    }
                }
                break;
            }
            case 'failure': {
                if (event.logged) {
                    return;
                }
                event.logged = true;
                const reason = event.reason;
                switch (reason) {
                    default: {
                        throw new Error(`Unknown failure reason: ${unreachable(reason)}`);
                    }
                    case 'launched-incorrectly': {
                        this.console.error(`‚ùå${prefix} wireit must be launched with "npm run" or a compatible command.`);
                        this.console.error(`    More info: ${event.detail}`);
                        break;
                    }
                    case 'missing-package-json': {
                        this.console.error(`‚ùå${prefix} No package.json was found in ${event.script.packageDir}`);
                        break;
                    }
                    case 'invalid-json-syntax': {
                        for (const diagnostic of event.diagnostics) {
                            this.console.error(this.#diagnosticPrinter.print(diagnostic));
                        }
                        break;
                    }
                    case 'no-scripts-in-package-json': {
                        this.console.error(`‚ùå${prefix} No "scripts" section defined in package.json in ${event.script.packageDir}`);
                        break;
                    }
                    case 'script-not-found':
                    case 'wireit-config-but-no-script':
                    case 'duplicate-dependency':
                    case 'script-not-wireit':
                    case 'invalid-config-syntax':
                    case 'cycle':
                    case 'dependency-on-missing-package-json':
                    case 'dependency-on-missing-script': {
                        this.console.error(this.#diagnosticPrinter.print(event.diagnostic));
                        break;
                    }
                    case 'invalid-usage': {
                        this.console.error(`‚ùå${prefix} Invalid usage: ${event.message}`);
                        break;
                    }
                    case 'exit-non-zero': {
                        this.console.error(`‚ùå${prefix} Failed with exit status ${event.status}`);
                        break;
                    }
                    case 'signal': {
                        this.console.error(`‚ùå${prefix} Failed with signal ${event.signal}`);
                        break;
                    }
                    case 'spawn-error': {
                        this.console.error(`‚ùå${prefix} Process spawn error: ${event.message}`);
                        break;
                    }
                    case 'start-cancelled': {
                        // The script never started. We don't really need to log this, it's
                        // fairly noisy. Maybe in a verbose mode.
                        break;
                    }
                    case 'failed-previous-watch-iteration': {
                        this.console.error(`‚ùå${prefix} Failed on previous watch iteration`);
                        break;
                    }
                    case 'killed': {
                        this.console.error(`üíÄ${prefix} Killed`);
                        break;
                    }
                    case 'unknown-error-thrown': {
                        this.console.error(`‚ùå${prefix} Internal error! Please file a bug at https://github.com/google/wireit/issues/new, mention this message, that you encountered it in wireit version ${getWireitVersion()}, and give information about your package.json files.\n    Unknown error thrown: ${String(event.error)}`);
                        const maybeError = event.error;
                        if (maybeError?.stack) {
                            this.console.error(maybeError.stack);
                        }
                        break;
                    }
                    case 'dependency-invalid': {
                        this.console.error(`‚ùå${prefix} Depended, perhaps indirectly, on ${labelForScript(this.#rootPackageDir, event.dependency)} which could not be validated. Please file a bug at https://github.com/google/wireit/issues/new, mention this message, that you encountered it in wireit version ${getWireitVersion()}, and give information about your package.json files.`);
                        break;
                    }
                    case 'service-exited-unexpectedly': {
                        this.console.error(`‚ùå${prefix} Service exited unexpectedly`);
                        break;
                    }
                    case 'aborted':
                    case 'dependency-service-exited-unexpectedly': {
                        // These event isn't very useful to log, because they are downstream
                        // of failures that already get reported elsewhere.
                        break;
                    }
                }
                break;
            }
            case 'output': {
                const stream = event.stream;
                switch (stream) {
                    default: {
                        throw new Error(`Unknown output stream: ${unreachable(stream)}`);
                    }
                    // TODO(aomarks) More advanced handling of output streams so that
                    // output isn't simply interweaved.
                    case 'stdout': {
                        this.console.stdout.write(event.data);
                        break;
                    }
                    case 'stderr': {
                        this.console.stderr.write(event.data);
                        break;
                    }
                }
                break;
            }
            case 'info': {
                const detail = event.detail;
                switch (detail) {
                    default: {
                        throw new Error(`Unknown info event detail: ${unreachable(detail)}`);
                    }
                    case 'running': {
                        this.console.log(`üèÉ${prefix} Running command "${event.script.command?.value ?? ''}"`);
                        break;
                    }
                    case 'locked': {
                        this.console.log(`üí§${prefix} Waiting for another process which is already running this script.`);
                        break;
                    }
                    case 'output-modified': {
                        this.console.log(`‚ÑπÔ∏è${prefix} Output files were modified since the previous run.`);
                        break;
                    }
                    case 'watch-run-start': {
                        if (process.stdout.isTTY) {
                            // If we are in an interactive terminal (TTY), reset it before
                            // each run. This is helpful because it means only the output for
                            // the current build is visible. This is exactly the same as what
                            // "tsc --watch" does.
                            //
                            // This string is the ESC character (ASCII \x1B) followed by "c",
                            // which is the VT100 reset sequence, supported by most terminals:
                            // https://www2.ccs.neu.edu/research/gpc/VonaUtils/vona/terminal/vtansi.htm#:~:text=Reset%20Device
                            this.console.log('\x1Bc');
                        }
                        break;
                    }
                    case 'watch-run-end': {
                        this.console.log(`üëÄ${prefix} Watching for file changes`);
                        break;
                    }
                    case 'cache-info': {
                        this.console.log(`‚ÑπÔ∏è${prefix} ${event.message}`);
                        break;
                    }
                    case 'service-process-started': {
                        this.console.log(`‚¨ÜÔ∏è${prefix} Service starting...`);
                        break;
                    }
                    case 'service-ready': {
                        this.console.log(`‚¨ÜÔ∏è${prefix} Service ready`);
                        break;
                    }
                    case 'service-stopped': {
                        this.console.log(`‚¨áÔ∏è${prefix} Service stopped`);
                        break;
                    }
                    case 'analysis-started':
                    case 'analysis-completed': {
                        break;
                    }
                }
            }
        }
    }
    printMetrics() {
        // printMetrics() not used in default-logger.
    }
    getWatchLogger() {
        return new WatchLogger(this);
    }
    [Symbol.dispose]() {
        this.console[Symbol.dispose]();
    }
}
/**
 * Make a concise label for a script, or for just a package if we don't know
 * the script name. If the package is different to the root package, it is
 * disambiguated with a relative path.
 */
export function labelForScript(rootPackageDir, script) {
    const packageDir = script.packageDir;
    const scriptName = 'name' in script ? script.name : undefined;
    if (packageDir !== rootPackageDir) {
        const relativePackageDir = pathlib
            .relative(rootPackageDir, script.packageDir)
            // Normalize to posix-style forward-slashes as the path separator, even
            // on Windows which usually uses back-slashes. This way labels match the
            // syntax used in the package.json dependency specifiers (which are
            // already posix style).
            .replace(pathlib.sep, pathlib.posix.sep);
        if (scriptName !== undefined) {
            return `${relativePackageDir}:${scriptName}`;
        }
        else {
            return relativePackageDir;
        }
    }
    else if (scriptName !== undefined) {
        return scriptName;
    }
    return '';
}
//# sourceMappingURL=default-logger.js.map