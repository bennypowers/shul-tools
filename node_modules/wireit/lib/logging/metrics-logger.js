/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { hrtime } from 'process';
import { DefaultLogger } from './default-logger.js';
// To prevent using the global console accidentally, we shadow it with
// undefined
const console = undefined;
function markAsUsed(_) { }
markAsUsed(console);
/**
 * A {@link Logger} that keeps track of metrics.
 */
export class MetricsLogger extends DefaultLogger {
    #startTime = hrtime();
    #metrics = [
        {
            name: 'Success',
            // 'no-command' is technically a success, but we don't want to count it as
            // a success for this metric because nothing was actually run.
            matches: (e) => e.type === 'success' && e.reason !== 'no-command',
            count: 0,
        },
        {
            name: 'Ran',
            matches: (e) => e.type === 'success' && e.reason === 'exit-zero',
            count: 0,
        },
        {
            name: 'Skipped (fresh)',
            matches: (e) => e.type === 'success' && e.reason === 'fresh',
            count: 0,
        },
        {
            name: 'Restored from cache',
            matches: (e) => e.type === 'success' && e.reason === 'cached',
            count: 0,
        },
    ];
    /**
     * @param rootPackage The npm package directory that the root script being
     * executed belongs to.
     */
    constructor(rootPackage, console) {
        super(rootPackage, console);
    }
    /**
     * Update relevant metrics for an event and pass it up to the parent logger.
     */
    log(event) {
        // When in watch mode, metrics should reset at the start of each run.
        if (event.type === 'info' && event.detail === 'watch-run-start') {
            this.#resetMetrics();
        }
        this.#updateMetrics(event);
        super.log(event);
    }
    /**
     * Log the current metrics and reset the state of each metric.
     */
    printMetrics() {
        const successes = this.#metrics[0].count ?? 0;
        if (!successes) {
            this.#resetMetrics();
            return;
        }
        const elapsed = this.#getElapsedTime();
        const nameOffset = 20;
        const out = [
            `üèÅ [metrics] Executed ${successes} script(s) in ${elapsed} seconds`,
        ];
        for (const metric of this.#metrics.slice(1)) {
            const name = metric.name.padEnd(nameOffset);
            const count = metric.count;
            const percent = this.#calculatePercentage(count, successes);
            out.push(`\t${name}: ${count} (${percent}%)`);
        }
        this.console.log(out.join('\n'));
        this.#resetMetrics();
    }
    #updateMetrics(event) {
        for (const metric of this.#metrics) {
            if (metric.matches(event)) {
                metric.count++;
            }
        }
    }
    #resetMetrics() {
        this.#startTime = hrtime();
        for (const metric of this.#metrics) {
            metric.count = 0;
        }
    }
    #getElapsedTime() {
        const [seconds, nanoseconds] = hrtime(this.#startTime);
        const time = seconds + nanoseconds / 1e9;
        return time.toFixed(2);
    }
    #calculatePercentage(numerator, denominator) {
        if (denominator === 0) {
            return 0;
        }
        return Math.floor((numerator / denominator) * 100);
    }
}
//# sourceMappingURL=metrics-logger.js.map