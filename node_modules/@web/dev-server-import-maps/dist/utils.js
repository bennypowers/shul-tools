"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequestImportMapId = exports.getDocumentBaseUrl = exports.withImportMapIdParam = exports.mergeImportMaps = exports.shouldInject = exports.normalizeInjectSetting = exports.IMPORT_MAP_PARAM = void 0;
const picomatch_1 = __importDefault(require("picomatch"));
const dev_server_core_1 = require("@web/dev-server-core");
const parse5_utils_1 = require("@web/parse5-utils");
exports.IMPORT_MAP_PARAM = 'wds-import-map';
function createMatchers(inject) {
    if (!inject.include && !inject.exclude) {
        return { include: (0, picomatch_1.default)('**/*') };
    }
    return {
        include: inject.include ? (0, picomatch_1.default)(inject.include) : undefined,
        exclude: inject.exclude ? (0, picomatch_1.default)(inject.exclude) : undefined,
    };
}
function normalizeInjectSetting(setting) {
    if (setting == null) {
        return [];
    }
    const injectedImportMaps = Array.isArray(setting) ? setting : [setting];
    return injectedImportMaps.map(i => (Object.assign({ importMap: i.importMap }, createMatchers(i))));
}
exports.normalizeInjectSetting = normalizeInjectSetting;
function shouldInject(path, setting) {
    // Treat directory paths such as `/foo/` as `/foo/index.html`
    const normalizedPath = path.endsWith('/') ? `${path}index.html` : path;
    const included = !setting.include || setting.include(normalizedPath);
    const excluded = setting.exclude && setting.exclude(normalizedPath);
    return included && !excluded;
}
exports.shouldInject = shouldInject;
function mergeImportMaps(a, b) {
    const merged = {
        imports: Object.assign(Object.assign({}, a.imports), b.imports),
        scopes: a.scopes ? Object.assign({}, a.scopes) : undefined,
    };
    if (b.scopes) {
        if (!merged.scopes) {
            merged.scopes = {};
        }
        for (const [key, value] of Object.entries(b.scopes)) {
            merged.scopes[key] = Object.assign(Object.assign({}, merged.scopes[key]), value);
        }
    }
    return merged;
}
exports.mergeImportMaps = mergeImportMaps;
function withImportMapIdParam(path, id) {
    const suffix = `${exports.IMPORT_MAP_PARAM}=${id}`;
    const hasParams = new URL(path, 'http://localhost/').searchParams.toString() === '';
    return hasParams ? `${path}?${suffix}` : `${path}&${suffix}`;
}
exports.withImportMapIdParam = withImportMapIdParam;
function getDocumentBaseUrl(context, baseNode) {
    if (baseNode) {
        const baseHref = (0, parse5_utils_1.getAttribute)(baseNode, 'href');
        if (typeof baseHref === 'string') {
            // there was a <base href="..."> on the page
            return new URL(baseHref, context.URL.href);
        }
    }
    // there was no <base href="...">, use the path
    return new URL('./', context.URL.href);
}
exports.getDocumentBaseUrl = getDocumentBaseUrl;
function getRequestImportMapId(context, importMapsIdsByHtmlPath) {
    if (context.response.is('html')) {
        // for HTML files get the import map based on the HTML path
        const htmlPath = (0, dev_server_core_1.getHtmlPath)(context.path);
        const importMapId = importMapsIdsByHtmlPath.get(htmlPath);
        // console.log({
        //   path: context.path,
        //   htmlPath,
        //   importMapId,
        //   keys: Array.from(importMapsIdsByHtmlPath.keys()),
        // });
        if (importMapId == null) {
            return;
        }
        return String(importMapId);
    }
    // for other files get the import map id from the module's query params
    return context.URL.searchParams.get(exports.IMPORT_MAP_PARAM);
}
exports.getRequestImportMapId = getRequestImportMapId;
//# sourceMappingURL=utils.js.map