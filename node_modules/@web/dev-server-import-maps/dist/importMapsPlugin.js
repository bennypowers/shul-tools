"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importMapsPlugin = void 0;
const dev_server_core_1 = require("@web/dev-server-core");
const resolve_1 = require("@import-maps/resolve");
const dev_server_core_2 = require("@web/dev-server-core");
const parse5_1 = require("parse5");
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
const parse5_utils_1 = require("@web/parse5-utils");
function prepend(parent, node) {
    // use 'any' because parse5 types are off
    parent.childNodes.unshift(node);
    node.parentNode = parent;
}
function importMapsPlugin(config = {}) {
    const injectSettings = (0, utils_1.normalizeInjectSetting)(config.inject);
    const importMapsById = [];
    const importMapsIdsByHtmlPath = new Map();
    let logger;
    let rootDir;
    return {
        name: 'import-map',
        serverStart(args) {
            ({ logger } = args);
            ({ rootDir } = args.config);
        },
        /**
         * Extracts import maps from HTML pages.
         */
        transform(context) {
            if (!context.response.is('html') || (0, parse5_utils_1.isHtmlFragment)(context.body)) {
                return;
            }
            let toInject = injectSettings.find(i => (0, utils_1.shouldInject)(context.path, i));
            // collect import map in HTML page
            const documentAst = (0, parse5_1.parse)(context.body);
            const headNode = (0, parse5_utils_1.findElement)(documentAst, el => (0, parse5_utils_1.getTagName)(el) === 'head');
            if (!headNode) {
                throw new Error('Internal error: HTML document did not generate a <head>.');
            }
            const importMapScripts = (0, parse5_utils_1.findElements)(documentAst, el => (0, parse5_utils_1.getTagName)(el) === 'script' && (0, parse5_utils_1.getAttribute)(el, 'type') === 'importmap');
            if (toInject && importMapScripts.length === 0) {
                // inject import map element into the page
                const script = (0, parse5_utils_1.createElement)('script', { type: 'importmap' });
                (0, parse5_utils_1.setTextContent)(script, JSON.stringify(toInject.importMap));
                importMapScripts.push(script);
                prepend(headNode, script);
                toInject = undefined;
            }
            if (importMapScripts.length === 0) {
                // HTML page has no import map
                return;
            }
            if (importMapScripts.length !== 1) {
                logger.warn('Multiple import maps on a page are not supported, using the first import map found.');
            }
            const [importMapScript] = importMapScripts;
            if ((0, parse5_utils_1.getAttribute)(importMapScript, 'src')) {
                throw new Error('Import maps with a "src" attribute are not yet supported.');
            }
            const htmlPath = (0, dev_server_core_2.getHtmlPath)(context.path);
            const importMapString = (0, parse5_utils_1.getTextContent)(importMapScript);
            let importMapId = importMapsById.findIndex(i => i.importMapString === importMapString);
            if (importMapId === -1) {
                // this is the first time we encounter this import map for this
                const baseNode = (0, parse5_utils_1.findElement)(headNode, el => (0, parse5_utils_1.getTagName)(el) === 'base');
                const documentBaseUrl = (0, utils_1.getDocumentBaseUrl)(context, baseNode);
                // parse the import map and store it with the HTML path
                try {
                    let importMap = (0, resolve_1.parseFromString)(importMapString, documentBaseUrl);
                    if (toInject) {
                        // we have to inject an import map but there was already one in the HTML file
                        // we merge it with the existing import
                        const parsedImportMapToInject = (0, resolve_1.parse)(toInject.importMap, documentBaseUrl);
                        importMap = (0, utils_1.mergeImportMaps)(parsedImportMapToInject, importMap);
                        (0, parse5_utils_1.setTextContent)(importMapScript, JSON.stringify(importMap));
                        toInject = undefined;
                    }
                    importMapsById.push({ htmlPath, importMap, importMapString });
                    importMapId = importMapsById.length - 1;
                }
                catch (error) {
                    const filePath = (0, dev_server_core_1.getRequestFilePath)(context.url, rootDir);
                    const relativeFilePath = path_1.default.relative(process.cwd(), filePath);
                    logger.warn(`Failed to parse import map in "${relativeFilePath}": ${error.message}`);
                    return;
                }
            }
            importMapsIdsByHtmlPath.set(htmlPath, importMapId);
            const scripts = (0, parse5_utils_1.findElements)(documentAst, el => (0, parse5_utils_1.getTagName)(el) === 'script' && (0, parse5_utils_1.hasAttribute)(el, 'src'));
            const links = (0, parse5_utils_1.findElements)(documentAst, el => {
                var _a;
                return (0, parse5_utils_1.getTagName)(el) === 'link' &&
                    ['preload', 'prefetch', 'modulepreload'].includes((_a = (0, parse5_utils_1.getAttribute)(el, 'rel')) !== null && _a !== void 0 ? _a : '') &&
                    (0, parse5_utils_1.hasAttribute)(el, 'href');
            });
            // add import map id to all script tags
            for (const script of scripts) {
                const src = (0, parse5_utils_1.getAttribute)(script, 'src');
                if (src) {
                    (0, parse5_utils_1.setAttribute)(script, 'src', (0, utils_1.withImportMapIdParam)(src, String(importMapId)));
                }
            }
            // add import map id to all preload links
            for (const link of links) {
                const href = (0, parse5_utils_1.getAttribute)(link, 'href');
                if (href) {
                    (0, parse5_utils_1.setAttribute)(link, 'href', (0, utils_1.withImportMapIdParam)(href, String(importMapId)));
                }
            }
            return (0, parse5_1.serialize)(documentAst);
        },
        /**
         * Add import map param to imports in inline modules.
         */
        transformImport({ source, context }) {
            const importMapId = (0, utils_1.getRequestImportMapId)(context, importMapsIdsByHtmlPath);
            if (importMapId == null) {
                return;
            }
            return (0, utils_1.withImportMapIdParam)(source, String(importMapId));
        },
        /**
         * Resolves imports using import maps. When the source file contains an import map
         * search parameter, we look up the associated import map and use that to resolve
         * the import.
         */
        resolveImport({ source, context }) {
            const importMapId = (0, utils_1.getRequestImportMapId)(context, importMapsIdsByHtmlPath);
            if (importMapId == null) {
                return;
            }
            const data = importMapsById[Number(importMapId)];
            if (!data) {
                throw Error(`Something went wrong resolving an import map. Could not find import map with id ${importMapId}.` +
                    ` Are you adding the URL search parameter ${utils_1.IMPORT_MAP_PARAM} manually?`);
            }
            const { resolvedImport, matched } = (0, resolve_1.resolve)(source, data.importMap, context.URL);
            // console.log({ resolvedImport });
            if (matched && resolvedImport) {
                return resolvedImport.href.startsWith(context.URL.origin)
                    ? resolvedImport.pathname
                    : resolvedImport.href;
            }
        },
    };
}
exports.importMapsPlugin = importMapsPlugin;
//# sourceMappingURL=importMapsPlugin.js.map